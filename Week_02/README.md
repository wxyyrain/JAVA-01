## GC日志解读与分析

* 打印GC日志：-XX:+PrintGCDetails
* 打印日志信息到文件：-Xloggc:gc.log
    * %p，pid：-Xloggc:gc_%p.log
    * %t，时间：-Xloggc:gc_%t.log
    * 冒号后面可以使绝对路径或者相对路径
    * 会自动加上-XX:+PrintGCTimeStamps，打印gc的时间（虚拟机启动后开始计算的时间），-XX:+PrintGCDateStamps会打印年月日
    * CommandLine flags 中会有一些配置参数，例如堆内存的大小，使用的收集器
* 指定垃圾收集器
    * -XX:+UseSerialGC
    * -XX:+UseParallelGC （与下面一行等价）
    * -XX:+UseParallelGC  -XX:+UseParallelGC
    * -XX:+UseConcMarkSweepGC（年轻代默认ParNew）
        * 使用CMS时，命令行参数会自动计算出年轻代、年老代的初始值、最大值，以及最大晋升阈值
    * -XX:+UseConcMarkSweepGC  -XX:+UseParNewGC（单独老年代默认SerialOld）
    * -XX:+UseG1GC
        * 原则上不指定年轻代大小，因为G1回收方式是小批量划定区块进行，可能在某次GC中既有年轻代又有年老代，可能某个区块一回事年老代，一会变成年轻代
* GC类型
    * Minor GC：小型GC
        * 当JVM无法为新对象分配内存空间时触发（eden区满了）。如果对象的分配速率很快，那么Minor GC次数也就会很多，频率也就会很快
        * 不处理老年代，把所有从老年代指向年轻代的引用当做GC Root，从年轻代指向老年代的引用则在标记阶段被忽略
        * 每次都会stw，但stw时间可以忽略不计，因为eden大部分对象都是垃圾，如果不符合这种情况，stw时间就会增大，有比较明显的GC性能影响
        * 清理的是年轻代，又叫young gc
    * Major GC：大型GC（老年代的内存清理）、Full GC：完全GC（整个堆的内存清理）
        * Major 和Full有时候不能很好区分，有时候Major是由Minor触发的
        * 会造成比较长的stw时间
* 分析
    * gceasy.io
## JVM线程堆栈数据分析

* jvm内部线程
    * vm线程
    * 定时任务线程
    * gc线程
    * 编译器线程
    * 信号分发线程
* 安全点
    * 方法代码中被植入的安全点检测入口
    * 线程处于安全点状态：线程暂停执行，这个时候线程栈不在发生改变
    * JVM的安全点状态：所有线程都处于安全点状态
* fastthread.io
## 内存分析相关工具

* 对象组成
    * 对象头
    * 对象体
    * 对齐填充
* 内存溢出解决思路
    * OutOfMemoryError: Java heap space
        * 增加内存
        * 看是否有内存泄漏
        * 看是否超过系统容量
    * OutOfMemoryError: PermGen space/OutOfMemoryError: Metaspace
        * 增加Perm/Meta的内存大小
        * 使用-XX:+CMSClassUnloadingEnabled参数
    * OutOfMemoryError: Unable to create new native thread
        * 调整系统参数 ulimit -a， echo 120000 > /proc/sys/kernel/threads-max
        * 降低xss等参数
        * 调整代码，改变线程创建和使用方式
* dunp分析工具
    * eclipse mat
    * jhat
## JVM问题分析调优经验

* 高分配速率：导致过大的GC开销，进而影响系统性能
    * 指标：
        * 正常系统： 分配速率较低 ~ 回收速率 -> 健康
        * 内存泄漏： 分配速率 持续大于 回收速率 -> OOM
        * 性能劣化： 分配速率较高 ~ 回收速率 -> 压健康
    * 解决
        * 增加eden
            * 影响minor gc的次数和时间，进而影响吞吐量
            * 某些情况可以降低分配速率过高带来的影响，不会降低分配速率，会减少gc频率，如果每次gc后只有少量对象存活，gc暂停时间不会明显变化
* 过早提升
    * 症状
        * 短时间内频繁full gc
        * 每次full gc后老年代使用率很低
        * 提升速率接近分配速率
    * 影响
        * 导致major频繁，gc时间长，影响系统吞吐量
    * 解决：让临时数据在年轻代能放下
        * 增加年轻代大小
        * 减少每次批处理的数量
## GC疑难情况问题分析

* 查询业务日志， 可以发现这类问题： 请求压力大， 波峰， 遭遇降级， 熔断等等， 基础服务、 外部 API依赖 。
* 查看系统资源和监控信息：
    * 硬件信息、 操作系统平台、 系统架构；
    * 排查 CPU 负载、 内存不足， 磁盘使用量、 硬件故障、 磁盘分区用满、 IO 等待、 IO 密集、 丢数据、 并发竞争等情况
    * 排查网络： 流量打满， 响应超时， 无响应， DNS 问题， 网络抖动， 防火墙问题， 物理故障， 网络参数调整、 超时、 连接数
* 查看性能指标， 包括实时监控、 历史数据。 可以发现 假死， 卡顿、 响应变慢等现象排查数据库， 并发连接数、 慢查询、 索引、 磁盘空间使用量、 内存使用量、 网络带宽、 死锁、 TPS、 查询数据量、 redo日志、 undo、 binlog 日志、 代理、 工具 BUG。 可以考虑的优化包括： 集群、 主备、 只读实例、 分片、 分区；大数据， 中间件， JVM 参数
* 排查系统日志， 比如重启、 崩溃、 Kill
* APM， 比如发现有些链路请求变慢等等
* 排查应用系统
    * 排查配置文件: 启动参数配置、 Spring 配置、 JVM 监控参数、 数据库参数、 Log 参数、APM 配置、内存问题， 比如是否存在内存泄漏， 内存溢出、 批处理导致的内存放大、 GC 问题等等
    * GC 问题， 确定 GC 算法、 确定 GC 的 KPI， GC 总耗时、 GC 最大暂停时间、 分析 GC 日志和监控指标：内存分配速度， 分代提升速度， 内存使用率等数据。 适当时修改内存配置
    * 排查线程, 理解线程状态、 并发线程数， 线程 Dump， 锁资源、 锁等待， 死锁
    * 排查代码， 比如安全漏洞、 低效代码、 算法优化、 存储优化、 架构调整、 重构、 解决业务代码 BUG、 第三方库、 XSS、 CORS、 正则
    * 单元测试： 覆盖率、 边界值、 Mock 测试、 集成测试
* 排除资源竞争、 坏邻居效应
* 疑难问题排查分析手段
    * DUMP 线程\内存；
    * 抽样分析\调整代码、 异步化、 削峰填谷
## 网络协议

* 五层协议
    * 应用层
        * 为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文
    * 传输层
        * 为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务
    * 网络层
        * 为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组
    * 数据链路层
        * 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧
    * 物理层
        * 考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异
* OSI
    * 表示层
        * 数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题
    * 会话层
        * 建立及管理会话
    * 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理
* TCP/IP
    * 它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层
    * TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层
## Socket

* socket通信模型
    * server（ip+port确保找到某个服务）与client建立连接，开始通信，结束连接
    * 七层网络模型，tcp四层，http七层
* 基于socketServer实现http服务器
    * 单线程响应-》多线程响应-》线程池响应
    * 服务中操作类型
        * CPU计算/业务处理
        * IO操作与等待/网络、磁盘、数据库
## IO模型

* 内核空间与用户空间
    * 操作系统内核：可以访问受保护的内存空间，拥有访问底层硬件设备的所有权限。
    * 为了保护内核的安全，操作系统将虚拟空间划分为：
        * 内核空间（内核代码运行的地方）
        * 用户空间（用户程序代码运行的地方）
        * 内核空间和用户空间是隔离的。用户程序不能直接操作内核，需要通过系统调用来与内核进行通信
* 对于一个socket的出入操作，通常包括两个阶段：
    * 等待数据从网络中到达（数据到达后，被复制到内核的缓冲区）
    * 把数据从内核缓冲区复制到用户应用进程缓冲区
* 五种IO模型（bio、nio、aio）
    * 阻塞式I/O
        * 解释：当应用进程调用了recv()这个系统调用，操作系统就开始了IO的第一个阶段，用户这边，整个进程会被阻塞，当内核等到数据准备好了，将数据从内核拷贝到用户内存，然后内核返回结果，用户进程解除阻塞
        * 特点：在IO的两个阶段都阻塞；阻塞式不消耗CPU时间
        * 场景：阻塞 Socket、Java BIO。适用并发较小的网络应用，并发较大的不适用，因为一个请求 IO 阻塞进程，就要为每个请求分配一个进程（线程）来响应，开销大
    * 非阻塞式I/O
        * 解释：当用户进程发出 recv() 操作时，如果内核中的数据还没有准备好，那么它并不会阻塞用户进程，而是立刻返回一个错误码。一旦内核中的数据准备好了，并且又再次收到了用户进程的系统调用，那么它马上就将数据拷贝到了用户内存，然后返回
        * 特点：在第二阶段阻塞；进程轮询调用（polling），消耗 CPU 资源
        * 场景：SOCKET 设置 NON BLOCKING 属性。支持并发量小，不用及时响应的网络应用
    * io多路复用（事件驱动）
        * 解释：当用户进程调用了 select（poll、epoll），那么整个进程会被阻塞，而此时，内核会监视所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回。这个时候用户进程再调用 recv 操作，将数据从内核拷贝到用户进程
        * 特点：第一阶段在select上阻塞，第二阶段依旧阻塞；性能好，Reactor模式
        * 场景：Java NIO，Nginx。适用高并发服务应用开发，一个进程/线程响应多个请求
    * 信号驱动式I/O
        * 解释：应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用recv()将数据从内核复制到应用进程中
        * 特点：第二阶段阻塞；通知机制，不是轮训；CPU利用高于非阻塞式IO
    * 异步I/O
        * 解释：应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号
        * 特点：两个阶段都不会阻塞；异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O
        * 场景：Java 7 AIO、高性能服务器，高性能高并发
## Netty：网络应用开发框架

* 特点
    * 异步
    * 事件驱动
    * 基于NIO
* 适用于
    * 服务端
    * 客户端
    * TCP/UDP
* 特性：
    * 高吞吐
    * 低延迟
    * 低开销
    * 零拷贝
    * 可扩容
    * 松耦合
    * 使用方便、可维护性好
* 兼容性
    * jdk
        * 3.x jdk5
        * 4.x jdk6
    * 协议
        * 兼容大部分通用协议
        * 支持自定义协议
* 嵌入式
    * http server
    * web server （有session。cookie等）
    * http3 server
    * TCP server
    * UDP server
    * webSocket
* netty vs java ee？
* 基本概念
    * channel
        * 通道， Java NIO 中的基础概念,代表一个打开的连接,可执行读取/写入 IO 操作。Netty 对 Channel 的所有 IO 操作都是非阻塞的
    * channelFuture
        * Java 的 Future 接口， 只能查询操作的完成情况, 或者阻塞当前线程等待操作完成。 Netty 封装一个 ChannelFuture 接口。我们可以将回调方法传给 ChannelFuture， 在操作完成时自动执行
    * Event & Handler：Netty 基于事件驱动， 事件和处理器可以关联到入站和出站数据流
        * 入站事件
        * 出站事件
            * 打开连接
            * 关闭连接
            * 写入数据
            * 刷新数据
        * 时间处理程序接口
    * Encoder & Decoder
        * 处理网络 IO 时， 需要进行序列化和反序列化, 转换 Java 对象与字节流。
        * 对入站数据进行解码, 基类是 ByteToMessageDecoder。
        * 对出站数据进行编码, 基类是 MessageToByteEncoder。
    * ChannelPipeline
        * 数据处理管道就是事件处理器链。有顺序、同一Channel的出站处理器和入站处理器在同一个列表中



